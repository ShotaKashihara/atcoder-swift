{
  "DFS (複雑だけど全探索するだけ)": {
    "scope": "swift",
    "prefix": "DFS (複雑だけど全探索するだけ)",
    "body": [
      "/// よくやる再帰関数の書き方",
      "/// https://drken1215.hatenablog.com/entry/2020/05/04/190252",
      "/// 自分で書いたコード例",
      "/// https://github.com/ShotaKashihara/atcoder-swift/blob/master/abc114/c/main.swift"
    ],
    "description": "よくやる再帰関数の書き方"
  },
  "bit全探索(index)": {
    "scope": "swift",
    "prefix": "bit全探索",
    "body": [
      "typealias Index = Int",
      "func bit全探索(n: Int) -> [[Index]] {",
      "    (0..<1<<n).map { bit in",
      "        var s = [Int]()",
      "        for i in 0..<n {",
      "            if bit & 1<<i > 0 {",
      "                s.append(i)",
      "            }",
      "        }",
      "        return s",
      "    }",
      "}"
    ]
  },
  "順列/組合わせ/全列挙": {
    "scope": "swift",
    "prefix": "permutation 順列 combination 組み合わせ repeatedPermutation 全列挙",
    "body": [
      "extension Array {",
      "    /// [1,2,3,4].permutation(length: 3)",
      "    /// -> [[1,2,3], [2,1,3], [3,1,2], [1,3,2] ... [3,4,2], [4,3,2]]",
      "    /// nPr = n!/(n-r)!",
      "    /// -> 4_P_3 = 4!/(4-3)! = 24",
      "    func permutation (length: Int) -> [[Element]] {",
      "        if length < 0 || length > self.count {",
      "            return []",
      "        } else if length == 0 {",
      "            return [[]]",
      "        } else {",
      "            var permutations: [[Element]] = []",
      "            let combinations = combination(length: length)",
      "            for combination in combinations {",
      "                var endArray: [[Element]] = []",
      "                var mutableCombination = combination",
      "                permutations += self.permutationHelper(n: length, array: &mutableCombination, endArray: &endArray)",
      "            }",
      "            return permutations",
      "        }",
      "    }",
      "    /// [1,2,3,4].combination(length: 3)",
      "    /// -> [[1,2,3], [1,2,4], [1,3,4], [2,3,4]]",
      "    /// nCr = nPr/r! = n!/(n-r)!r!",
      "    /// -> 4_C_3 = 4_P_3/3! = 24/6 = 4",
      "    func combination (length: Int) -> [[Element]] {",
      "        if length < 0 || length > self.count {",
      "            return []",
      "        }",
      "        var indexes: [Int] = (0..<length).reduce([]) {$0 + [$1]}",
      "        var combinations: [[Element]] = []",
      "        let offset = self.count - indexes.count",
      "        while true {",
      "            var combination: [Element] = []",
      "            for index in indexes {",
      "                combination.append(self[index])",
      "            }",
      "            combinations.append(combination)",
      "            var i = indexes.count - 1",
      "            while i >= 0 && indexes[i] == i + offset {",
      "                i -= 1",
      "            }",
      "            if i < 0 {",
      "                break",
      "            }",
      "            i += 1",
      "            let start = indexes[i-1] + 1",
      "            for j in (i-1)..<indexes.count {",
      "                indexes[j] = start + j - i + 1",
      "            }",
      "        }",
      "        return combinations",
      "    }",
      "    /// [1,2,3,4].repeatedPermutation(length: 3)",
      "    /// -> [[1,1,1], [1,1,2], [1,1,3], [1,1,4], [1,2,1] ... [4,4,4]]",
      "    func repeatedPermutation(length: Int) -> [[Element]] {",
      "        if length < 1 {",
      "            return []",
      "        }",
      "        var indexes: [[Int]] = []",
      "        indexes.repeatedPermutationHelper(seed: [], length: length, arrayLength: self.count, indexes: &indexes)",
      "        return indexes.map({ $0.map({ i in self[i] }) })",
      "    }",
      "    private func permutationHelper(n: Int, array: inout [Element], endArray: inout [[Element]]) -> [[Element]] {",
      "        if n == 1 {",
      "            endArray += [array]",
      "        }",
      "        for i in (0..<n) {",
      "            permutationHelper(n: n - 1, array: &array, endArray: &endArray)",
      "            let j = n % 2 == 0 ? i : 0",
      "            let temp: Element = array[j]",
      "            array[j] = array[n - 1]",
      "            array[n - 1] = temp ",
      "        }",
      "        return endArray",
      "    }",
      "    private func repeatedPermutationHelper(seed: [Int], length: Int, arrayLength: Int, indexes: inout [[Int]]) {",
      "        if seed.count == length {",
      "            indexes.append(seed)",
      "            return",
      "        }",
      "        for i in (0..<arrayLength) {",
      "            var newSeed: [Int] = seed",
      "            newSeed.append(i)",
      "            self.repeatedPermutationHelper(seed: newSeed, length: length, arrayLength: arrayLength, indexes: &indexes)",
      "        }",
      "    }",
      "}"
    ],
    "description": "permutation 順列"
  },
  "正規表現": {
    "scope": "swift",
    "prefix": "regex 正規表現",
    "body": [
      "extension String {",
      "  // e.g. cin.line.regex(match: \"^(dream|dreamer|erase|eraser)*$\")",
      "  func regex(match pattern: String) -> Bool {",
      "      let regex = try! NSRegularExpression(pattern: pattern)",
      "      return regex.firstMatch(in: self, range: NSRange(location: 0, length: self.count)) != nil",
      "  }",
      "}",
    ],
    "description": "よくやる再帰関数の書き方"
  },
}